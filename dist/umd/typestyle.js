/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["typestyle"] = factory();
	else
		root["typestyle"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hid = exports.stylesheet = exports.style = exports.reinit = exports.keyframes = exports.getStyles = exports.fontFace = exports.forceRenderStyles = exports.cssRule = exports.cssRaw = exports.setStylesTarget = exports.media = exports.classes = exports.extend = exports.types = exports.TypeStyle = void 0;\nexports.createTypeStyle = createTypeStyle;\nvar typestyle_1 = __webpack_require__(/*! ./internal/typestyle */ \"./lib/internal/typestyle.js\");\nObject.defineProperty(exports, \"TypeStyle\", ({ enumerable: true, get: function () { return typestyle_1.TypeStyle; } }));\n/**\n * All the CSS types in the 'types' namespace\n */\nvar types = __webpack_require__(/*! ./types */ \"./lib/types.js\");\nexports.types = types;\n/**\n * Export certain utilities\n */\nvar utilities_1 = __webpack_require__(/*! ./internal/utilities */ \"./lib/internal/utilities.js\");\nObject.defineProperty(exports, \"extend\", ({ enumerable: true, get: function () { return utilities_1.extend; } }));\nObject.defineProperty(exports, \"classes\", ({ enumerable: true, get: function () { return utilities_1.classes; } }));\nObject.defineProperty(exports, \"media\", ({ enumerable: true, get: function () { return utilities_1.media; } }));\n/** Zero configuration, default instance of TypeStyle */\nvar ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });\n/** Sets the target tag where we write the css on style updates */\nexports.setStylesTarget = ts.setStylesTarget;\n/**\n * Insert `raw` CSS as a string. This is useful for e.g.\n * - third party CSS that you are customizing with template strings\n * - generating raw CSS in JavaScript\n * - reset libraries like normalize.css that you can use without loaders\n */\nexports.cssRaw = ts.cssRaw;\n/**\n * Takes CSSProperties and registers it to a global selector (body, html, etc.)\n */\nexports.cssRule = ts.cssRule;\n/**\n * Renders styles to the singleton tag imediately\n * NOTE: You should only call it on initial render to prevent any non CSS flash.\n * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.\n **/\nexports.forceRenderStyles = ts.forceRenderStyles;\n/**\n * Utility function to register an @font-face\n */\nexports.fontFace = ts.fontFace;\n/**\n * Allows use to use the stylesheet in a node.js environment\n */\nexports.getStyles = ts.getStyles;\n/**\n * Takes keyframes and returns a generated animationName\n */\nexports.keyframes = ts.keyframes;\n/**\n * Helps with testing. Reinitializes FreeStyle + raw\n */\nexports.reinit = ts.reinit;\n/**\n * Takes CSSProperties and return a generated className you can use on your component\n */\nexports.style = ts.style;\n/**\n * Takes an object where property names are ideal class names and property values are CSSProperties, and\n * returns an object where property names are the same ideal class names and the property values are\n * the actual generated class names using the ideal class name as the $debugName\n */\nexports.stylesheet = ts.stylesheet;\n/**\n * Creates a new instance of TypeStyle separate from the default instance.\n *\n * - Use this for creating a different typestyle instance for a shadow dom component.\n * - Use this if you don't want an auto tag generated and you just want to collect the CSS.\n *\n * NOTE: styles aren't shared between different instances.\n */\nfunction createTypeStyle(target) {\n    var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });\n    if (target) {\n        instance.setStylesTarget(target);\n    }\n    return instance;\n}\nexports.hid = '[a-z0-9]{1,8}';\n\n\n//# sourceURL=webpack://typestyle/./lib/index.js?");

/***/ }),

/***/ "./lib/internal/formatting.js":
/*!************************************!*\
  !*** ./lib/internal/formatting.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertToStyles = convertToStyles;\nexports.convertToKeyframes = convertToKeyframes;\n/**\n * We need to do the following to *our* objects before passing to freestyle:\n * - For any `$nest` directive move up to FreeStyle style nesting\n * - For any `$unique` directive map to FreeStyle Unique\n * - For any `$debugName` directive return the debug name\n */\nfunction convertToStyles(object) {\n    /** The final result we will return */\n    var styles = {};\n    for (var key in object) {\n        /** Grab the value upfront */\n        var val = object[key];\n        /** TypeStyle configuration options */\n        if (key === '$nest') {\n            var nested = val;\n            for (var selector in nested) {\n                var subproperties = nested[selector];\n                styles[selector] = convertToStyles(subproperties);\n            }\n        }\n        else if (key === '$debugName') {\n            styles.$displayName = val;\n        }\n        else {\n            styles[key] = val;\n        }\n    }\n    return styles;\n}\n// todo: better name here\nfunction convertToKeyframes(frames) {\n    var result = {};\n    for (var offset in frames) {\n        if (offset !== '$debugName') {\n            result[offset] = frames[offset];\n        }\n    }\n    if (frames.$debugName) {\n        result.$displayName = frames.$debugName;\n    }\n    return result;\n}\n\n\n//# sourceURL=webpack://typestyle/./lib/internal/formatting.js?");

/***/ }),

/***/ "./lib/internal/typestyle.js":
/*!***********************************!*\
  !*** ./lib/internal/typestyle.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypeStyle = void 0;\nvar FreeStyle = __webpack_require__(/*! free-style */ \"./node_modules/free-style/dist/index.js\");\nvar formatting_1 = __webpack_require__(/*! ./formatting */ \"./lib/internal/formatting.js\");\nvar utilities_1 = __webpack_require__(/*! ./utilities */ \"./lib/internal/utilities.js\");\n/**\n * Creates an instance of free style with our options\n */\nvar createFreeStyle = function () { return FreeStyle.create(); };\n/**\n * Maintains a single stylesheet and keeps it in sync with requested styles\n */\nvar TypeStyle = /** @class */ (function () {\n    function TypeStyle(_a) {\n        var autoGenerateTag = _a.autoGenerateTag;\n        var _this = this;\n        /**\n         * Insert `raw` CSS as a string. This is useful for e.g.\n         * - third party CSS that you are customizing with template strings\n         * - generating raw CSS in JavaScript\n         * - reset libraries like normalize.css that you can use without loaders\n         */\n        this.cssRaw = function (mustBeValidCSS) {\n            if (!mustBeValidCSS) {\n                return;\n            }\n            _this._raw += mustBeValidCSS || '';\n            _this._pendingRawChange = true;\n            _this._styleUpdated();\n        };\n        /**\n         * Takes CSSProperties and registers it to a global selector (body, html, etc.)\n         */\n        this.cssRule = function (selector) {\n            var _a;\n            var objects = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                objects[_i - 1] = arguments[_i];\n            }\n            var styles = (0, formatting_1.convertToStyles)(utilities_1.extend.apply(void 0, objects));\n            _this._freeStyle.registerStyle((_a = {\n                    $global: true\n                },\n                _a[selector] = styles,\n                _a));\n            _this._styleUpdated();\n            return;\n        };\n        /**\n         * Renders styles to the singleton tag imediately\n         * NOTE: You should only call it on initial render to prevent any non CSS flash.\n         * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.\n         **/\n        this.forceRenderStyles = function () {\n            var target = _this._getTag();\n            if (!target) {\n                return;\n            }\n            target.textContent = _this.getStyles();\n        };\n        /**\n         * Utility function to register an @font-face\n         */\n        this.fontFace = function () {\n            var fontFace = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                fontFace[_i] = arguments[_i];\n            }\n            var freeStyle = _this._freeStyle;\n            for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {\n                var face = _b[_a];\n                freeStyle.registerStyle({\n                    $global: true,\n                    '@font-face': face\n                });\n            }\n            _this._styleUpdated();\n            return;\n        };\n        /**\n         * Allows use to use the stylesheet in a node.js environment\n         */\n        this.getStyles = function () {\n            return (_this._raw || '') + _this._freeStyle.getStyles();\n        };\n        /**\n         * Takes keyframes and returns a generated animationName\n         */\n        this.keyframes = function (frames) {\n            var keyframes = (0, formatting_1.convertToKeyframes)(frames);\n            // TODO: replace $debugName with display name\n            var animationName = _this._freeStyle.registerStyle({\n                $global: true,\n                $displayName: keyframes.$displayName,\n                \"@keyframes &\": keyframes\n            });\n            _this._styleUpdated();\n            return animationName;\n        };\n        /**\n         * Helps with testing. Reinitializes FreeStyle + raw\n         */\n        this.reinit = function () {\n            /** reinit freestyle */\n            var freeStyle = createFreeStyle();\n            _this._freeStyle = freeStyle;\n            _this._lastFreeStyleChangeId = freeStyle.changeId;\n            /** reinit raw */\n            _this._raw = '';\n            _this._pendingRawChange = false;\n            /** Clear any styles that were flushed */\n            var target = _this._getTag();\n            if (target) {\n                target.textContent = '';\n            }\n        };\n        /** Sets the target tag where we write the css on style updates */\n        this.setStylesTarget = function (tag) {\n            /** Clear any data in any previous tag */\n            if (_this._tag) {\n                _this._tag.textContent = '';\n            }\n            _this._tag = tag;\n            /** This special time buffer immediately */\n            _this.forceRenderStyles();\n        };\n        /**\n         * Takes an object where property names are ideal class names and property values are CSSProperties, and\n         * returns an object where property names are the same ideal class names and the property values are\n         * the actual generated class names using the ideal class name as the $debugName\n         */\n        this.stylesheet = function (classes) {\n            var classNames = Object.getOwnPropertyNames(classes);\n            var result = {};\n            for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {\n                var className = classNames_1[_i];\n                var classDef = classes[className];\n                if (classDef) {\n                    classDef.$debugName = className;\n                    result[className] = _this.style(classDef);\n                }\n            }\n            return result;\n        };\n        var freeStyle = createFreeStyle();\n        this._autoGenerateTag = autoGenerateTag;\n        this._freeStyle = freeStyle;\n        this._lastFreeStyleChangeId = freeStyle.changeId;\n        this._pending = 0;\n        this._pendingRawChange = false;\n        this._raw = '';\n        this._tag = undefined;\n        // rebind prototype to TypeStyle.  It might be better to do a function() { return this.style.apply(this, arguments)}\n        this.style = this.style.bind(this);\n    }\n    /**\n     * Only calls cb all sync operations settle\n     */\n    TypeStyle.prototype._afterAllSync = function (cb) {\n        var _this = this;\n        this._pending++;\n        var pending = this._pending;\n        (0, utilities_1.raf)(function () {\n            if (pending !== _this._pending) {\n                return;\n            }\n            cb();\n        });\n    };\n    TypeStyle.prototype._getTag = function () {\n        if (this._tag) {\n            return this._tag;\n        }\n        if (this._autoGenerateTag) {\n            var tag = typeof window === 'undefined'\n                ? { textContent: '' }\n                : document.createElement('style');\n            if (typeof document !== 'undefined') {\n                document.head.appendChild(tag);\n            }\n            this._tag = tag;\n            return tag;\n        }\n        return undefined;\n    };\n    /** Checks if the style tag needs updating and if so queues up the change */\n    TypeStyle.prototype._styleUpdated = function () {\n        var _this = this;\n        var changeId = this._freeStyle.changeId;\n        var lastChangeId = this._lastFreeStyleChangeId;\n        if (!this._pendingRawChange && changeId === lastChangeId) {\n            return;\n        }\n        this._lastFreeStyleChangeId = changeId;\n        this._pendingRawChange = false;\n        this._afterAllSync(function () { return _this.forceRenderStyles(); });\n    };\n    TypeStyle.prototype.style = function () {\n        var className = this._freeStyle.registerStyle((0, formatting_1.convertToStyles)(utilities_1.extend.apply(undefined, arguments)));\n        this._styleUpdated();\n        return className;\n    };\n    return TypeStyle;\n}());\nexports.TypeStyle = TypeStyle;\n\n\n//# sourceURL=webpack://typestyle/./lib/internal/typestyle.js?");

/***/ }),

/***/ "./lib/internal/utilities.js":
/*!***********************************!*\
  !*** ./lib/internal/utilities.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.media = exports.raf = void 0;\nexports.classes = classes;\nexports.extend = extend;\n/** Raf for node + browser */\nexports.raf = typeof requestAnimationFrame === 'undefined'\n    /**\n     * Make sure setTimeout is always invoked with\n     * `this` set to `window` or `global` automatically\n     **/\n    ? function (cb) { return setTimeout(cb); }\n    /**\n     * Make sure window.requestAnimationFrame is always invoked with `this` window\n     * We might have raf without window in case of `raf/polyfill` (recommended by React)\n     **/\n    : typeof window === 'undefined'\n        ? requestAnimationFrame\n        : requestAnimationFrame.bind(window);\n/**\n * Utility to join classes conditionally\n */\nfunction classes() {\n    var classes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        classes[_i] = arguments[_i];\n    }\n    return classes\n        .map(function (c) { return c && typeof c === 'object' ? Object.keys(c).map(function (key) { return !!c[key] && key; }) : [c]; })\n        .reduce(function (flattened, c) { return flattened.concat(c); }, [])\n        .filter(function (c) { return !!c; })\n        .join(' ');\n}\n/**\n * Merges various styles into a single style object.\n * Note: if two objects have the same property the last one wins\n */\nfunction extend() {\n    var objects = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        objects[_i] = arguments[_i];\n    }\n    /** The final result we will return */\n    var result = {};\n    for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {\n        var object = objects_1[_a];\n        if (object == null || object === false) {\n            continue;\n        }\n        for (var key in object) {\n            /** Falsy values except a explicit 0 is ignored */\n            var val = object[key];\n            if (!val && val !== 0) {\n                continue;\n            }\n            /** if nested media or pseudo selector */\n            if (key === '$nest' && val) {\n                result[key] = result['$nest'] ? extend(result['$nest'], val) : val;\n            }\n            /** if freestyle sub key that needs merging. We come here due to our recursive calls */\n            else if ((key.indexOf('&') !== -1 || key.indexOf('@media') === 0)) {\n                result[key] = result[key] ? extend(result[key], val) : val;\n            }\n            else {\n                result[key] = val;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Utility to help customize styles with media queries. e.g.\n * ```\n * style(\n *  media({maxWidth:500}, {color:'red'})\n * )\n * ```\n */\nvar media = function (mediaQuery) {\n    var _a;\n    var objects = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        objects[_i - 1] = arguments[_i];\n    }\n    var mediaQuerySections = [];\n    if (mediaQuery.type)\n        mediaQuerySections.push(mediaQuery.type);\n    if (mediaQuery.orientation)\n        mediaQuerySections.push(\"(orientation: \".concat(mediaQuery.orientation, \")\"));\n    if (mediaQuery.minWidth)\n        mediaQuerySections.push(\"(min-width: \".concat(mediaLength(mediaQuery.minWidth), \")\"));\n    if (mediaQuery.maxWidth)\n        mediaQuerySections.push(\"(max-width: \".concat(mediaLength(mediaQuery.maxWidth), \")\"));\n    if (mediaQuery.minHeight)\n        mediaQuerySections.push(\"(min-height: \".concat(mediaLength(mediaQuery.minHeight), \")\"));\n    if (mediaQuery.maxHeight)\n        mediaQuerySections.push(\"(max-height: \".concat(mediaLength(mediaQuery.maxHeight), \")\"));\n    if (mediaQuery.prefersColorScheme)\n        mediaQuerySections.push(\"(prefers-color-scheme: \".concat(mediaQuery.prefersColorScheme, \")\"));\n    var stringMediaQuery = \"@media \".concat(mediaQuerySections.join(' and '));\n    var object = {\n        $nest: (_a = {},\n            _a[stringMediaQuery] = extend.apply(void 0, objects),\n            _a)\n    };\n    return object;\n};\nexports.media = media;\nvar mediaLength = function (value) {\n    return typeof value === 'string' ? value : \"\".concat(value, \"px\");\n};\n\n\n//# sourceURL=webpack://typestyle/./lib/internal/utilities.js?");

/***/ }),

/***/ "./lib/types.js":
/*!**********************!*\
  !*** ./lib/types.js ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://typestyle/./lib/types.js?");

/***/ }),

/***/ "./node_modules/free-style/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/free-style/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cache: () => (/* binding */ Cache),\n/* harmony export */   Rule: () => (/* binding */ Rule),\n/* harmony export */   Selector: () => (/* binding */ Selector),\n/* harmony export */   Sheet: () => (/* binding */ Sheet),\n/* harmony export */   Style: () => (/* binding */ Style),\n/* harmony export */   compile: () => (/* binding */ compile),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/**\n * The unique id is used for unique hashes.\n */\nlet uniqueId = 0;\n/**\n * Quick dictionary lookup for unit-less numbers.\n */\nconst CSS_NUMBER = new Set();\n/**\n * CSS properties that are valid unit-less numbers.\n *\n * Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js\n */\nconst CSS_NUMBER_KEYS = [\n    \"animation-iteration-count\",\n    \"border-image-outset\",\n    \"border-image-slice\",\n    \"border-image-width\",\n    \"box-flex\",\n    \"box-flex-group\",\n    \"box-ordinal-group\",\n    \"column-count\",\n    \"columns\",\n    \"counter-increment\",\n    \"counter-reset\",\n    \"flex\",\n    \"flex-grow\",\n    \"flex-positive\",\n    \"flex-shrink\",\n    \"flex-negative\",\n    \"flex-order\",\n    \"font-weight\",\n    \"grid-area\",\n    \"grid-column\",\n    \"grid-column-end\",\n    \"grid-column-span\",\n    \"grid-column-start\",\n    \"grid-row\",\n    \"grid-row-end\",\n    \"grid-row-span\",\n    \"grid-row-start\",\n    \"line-clamp\",\n    \"line-height\",\n    \"opacity\",\n    \"order\",\n    \"orphans\",\n    \"tab-size\",\n    \"widows\",\n    \"z-index\",\n    \"zoom\",\n    // SVG properties.\n    \"fill-opacity\",\n    \"flood-opacity\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n];\n// Add vendor prefixes to all unit-less properties.\nfor (const property of CSS_NUMBER_KEYS) {\n    for (const prefix of [\"-webkit-\", \"-ms-\", \"-moz-\", \"-o-\", \"\"]) {\n        CSS_NUMBER.add(prefix + property);\n    }\n}\n/**\n * Escape a CSS class name.\n */\nfunction escape(str) {\n    return str.replace(/[ !#$%&()*+,./;<=>?@[\\]^`{|}~\"'\\\\]/g, \"\\\\$&\");\n}\n/**\n * Interpolate the `&` with style name.\n */\nfunction interpolate(selector, styleName) {\n    return selector.replace(/&/g, styleName);\n}\n/**\n * Transform a JavaScript property into a CSS property.\n */\nfunction hyphenate(propertyName) {\n    return propertyName\n        .replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`)\n        .replace(/^ms-/, \"-ms-\"); // Internet Explorer vendor prefix.\n}\n/**\n * Generate a hash value from a string.\n */\nfunction stringHash(str) {\n    let value = 5381;\n    let len = str.length;\n    while (len--)\n        value = (value * 33) ^ str.charCodeAt(len);\n    return (value >>> 0).toString(36);\n}\n/**\n * Interpolate CSS selectors.\n */\nfunction child(selector, parent) {\n    if (selector.indexOf(\"&\") === -1)\n        return `${parent} ${selector}`;\n    return interpolate(selector, parent);\n}\n/**\n * Transform a style string to a CSS string.\n */\nfunction tupleToStyle([name, value]) {\n    if (typeof value === \"number\" && value && !CSS_NUMBER.has(name)) {\n        return `${name}:${value}px`;\n    }\n    return `${name}:${String(value)}`;\n}\n/**\n * Recursive loop building styles with deferred selectors.\n */\nfunction stylize(rulesList, stylesList, key, styles, parentClassName) {\n    const properties = [];\n    const nestedStyles = [];\n    // Sort keys before adding to styles.\n    for (const [key, value] of Object.entries(styles)) {\n        if (key.charCodeAt(0) !== 36 /* $ */ && value != null) {\n            if (Array.isArray(value)) {\n                const name = hyphenate(key);\n                for (let i = 0; i < value.length; i++) {\n                    const style = value[i];\n                    if (style != null)\n                        properties.push([name, style]);\n                }\n            }\n            else if (typeof value === \"object\") {\n                nestedStyles.push([key, value]);\n            }\n            else {\n                properties.push([hyphenate(key), value]);\n            }\n        }\n    }\n    const isUnique = !!styles.$unique;\n    const parent = styles.$global ? \"\" : parentClassName;\n    const style = properties.map(tupleToStyle).join(\";\");\n    let pid = style;\n    let selector = parent;\n    let childRules = rulesList;\n    let childStyles = stylesList;\n    if (key.charCodeAt(0) === 64 /* @ */) {\n        childRules = [];\n        childStyles = [];\n        // Nested styles support (e.g. `.foo > @media`).\n        if (parent && style) {\n            childStyles.push({ selector, style, isUnique });\n        }\n        // Add new rule to parent.\n        rulesList.push({\n            selector: key,\n            style: parent ? \"\" : style,\n            rules: childRules,\n            styles: childStyles,\n        });\n    }\n    else {\n        selector = parent ? (key ? child(key, parent) : parent) : key;\n        if (style) {\n            stylesList.push({ selector, style, isUnique });\n        }\n    }\n    for (const [name, value] of nestedStyles) {\n        pid += `|${name}#${stylize(childRules, childStyles, name, value, selector)}`;\n    }\n    return pid;\n}\n/**\n * Transform `stylize` tree into style objects.\n */\nfunction compose(cache, rulesList, stylesList, id, name) {\n    for (const { selector, style, isUnique } of stylesList) {\n        const key = interpolate(selector, name);\n        const item = new Style(style, isUnique ? String(++uniqueId) : id);\n        item.add(new Selector(key));\n        cache.add(item);\n    }\n    for (const { selector, style, rules, styles } of rulesList) {\n        const key = interpolate(selector, name);\n        const item = new Rule(key, style, id);\n        compose(item, rules, styles, id, name);\n        cache.add(item);\n    }\n}\n/**\n * Cache to list to styles.\n */\nfunction join(arr) {\n    let res = \"\";\n    for (let i = 0; i < arr.length; i++)\n        res += arr[i];\n    return res;\n}\n/**\n * Implement a cache/event emitter.\n */\nclass Cache {\n    constructor(changes) {\n        this.changes = changes;\n        this.changeId = 0;\n        this.sheet = [];\n        this.children = [];\n        this.counters = new Map();\n    }\n    add(style) {\n        const id = style.cid();\n        const count = this.counters.get(id) ?? 0;\n        this.counters.set(id, count + 1);\n        if (count === 0) {\n            const item = style.clone();\n            const index = this.children.push(item);\n            this.sheet.push(item.getStyles());\n            this.changeId++;\n            if (this.changes)\n                this.changes.add(item, index);\n        }\n        else if (style instanceof Cache) {\n            const index = this.children.findIndex((x) => x.cid() === id);\n            const item = this.children[index];\n            const prevChangeId = item.changeId;\n            item.merge(style);\n            if (item.changeId !== prevChangeId) {\n                this.sheet[index] = item.getStyles();\n                this.changeId++;\n                if (this.changes)\n                    this.changes.change(item, index);\n            }\n        }\n    }\n    remove(style) {\n        const id = style.cid();\n        const count = this.counters.get(id);\n        if (count) {\n            const index = this.children.findIndex((x) => x.cid() === id);\n            if (count === 1) {\n                const item = this.children[index];\n                this.counters.delete(id);\n                this.children.splice(index, 1);\n                this.sheet.splice(index, 1);\n                this.changeId++;\n                if (this.changes)\n                    this.changes.remove(item, index);\n            }\n            else if (style instanceof Cache) {\n                const item = this.children[index];\n                const prevChangeId = item.changeId;\n                this.counters.set(id, count - 1);\n                item.unmerge(style);\n                if (item.changeId !== prevChangeId) {\n                    this.sheet[index] = item.getStyles();\n                    this.changeId++;\n                    if (this.changes)\n                        this.changes.change(item, index);\n                }\n            }\n        }\n    }\n    merge(cache) {\n        for (const item of cache.children)\n            this.add(item);\n        return this;\n    }\n    unmerge(cache) {\n        for (const item of cache.children)\n            this.remove(item);\n        return this;\n    }\n}\n/**\n * Selector is a dumb class made to represent nested CSS selectors.\n */\nclass Selector {\n    constructor(selector) {\n        this.selector = selector;\n    }\n    cid() {\n        return this.selector;\n    }\n    getStyles() {\n        return this.selector;\n    }\n    clone() {\n        return this;\n    }\n}\n/**\n * The style container registers a style string with selectors.\n */\nclass Style extends Cache {\n    constructor(style, id) {\n        super();\n        this.style = style;\n        this.id = id;\n    }\n    cid() {\n        return `${this.id}|${this.style}`;\n    }\n    getStyles() {\n        return `${this.sheet.join(\",\")}{${this.style}}`;\n    }\n    clone() {\n        return new Style(this.style, this.id).merge(this);\n    }\n}\n/**\n * Implement rule logic for style output.\n */\nclass Rule extends Cache {\n    constructor(rule, style, id) {\n        super();\n        this.rule = rule;\n        this.style = style;\n        this.id = id;\n    }\n    cid() {\n        return `${this.id}|${this.rule}|${this.style}`;\n    }\n    getStyles() {\n        return `${this.rule}{${this.style}${join(this.sheet)}}`;\n    }\n    clone() {\n        return new Rule(this.rule, this.style, this.id).merge(this);\n    }\n}\n/**\n * The FreeStyle class implements the API for everything else.\n */\nclass Sheet extends Cache {\n    constructor(prefix, changes) {\n        super(changes);\n        this.prefix = prefix;\n    }\n    register(compiled) {\n        const className = `${this.prefix}${compiled.id}`;\n        if ( true && compiled.displayName) {\n            const name = `${compiled.displayName}_${className}`;\n            compose(this, compiled.rules, compiled.styles, compiled.id, escape(name));\n            return name;\n        }\n        compose(this, compiled.rules, compiled.styles, compiled.id, className);\n        return className;\n    }\n    registerStyle(styles) {\n        return this.register(compile(styles));\n    }\n    getStyles() {\n        return join(this.sheet);\n    }\n}\n/**\n * Exports a simple function to create a new instance.\n */\nfunction create(changes, prefix = \"\") {\n    return new Sheet(prefix, changes);\n}\n/**\n * Compile styles into a registerable object.\n */\nfunction compile(styles) {\n    const ruleList = [];\n    const styleList = [];\n    const pid = stylize(ruleList, styleList, \"\", styles, \".&\");\n    return {\n        id: stringHash(pid),\n        rules: ruleList,\n        styles: styleList,\n        displayName: styles.$displayName,\n    };\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://typestyle/./node_modules/free-style/dist/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});